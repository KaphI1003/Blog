# \[POI2006]Met

### 题目描述：

给出一棵N个结点的树，选择L条路径，覆盖这些路径上的结点，使得被覆盖到的结点数最多。

#### 输入格式

第一行两个正整数N、L(2 <= N <= 1,000,000, 0 <= L <= N)。下面有N-1行，每行两个正整数A和B(1 <= A, B <= N)，表示一条边(A,B)。

#### 输出格式

一个整数，表示最多能覆盖到多少结点。

##### 样例输入

17 3

1 2

3 2

2 4

5 2

5 6

5 8

7 8

9 8

5 10

10 13

13 14

10 12

12 11

15 17

15 16

15 10

##### 样例输出

13

#### 分析:

首先要发现的是一个贪心结论：

**选的链的两端一定是两个叶子节点**\`

因为如果不是叶子节点，那么链的长度一定可以延伸。这结论虽然容易发现但是这道题的重要思想之一。接着问题就转化为寻找几个叶子节点，使连线后的覆盖最大。

第二个结论是选的链要相交，理由见图：

$$
1-1-1

  | 
  
  0
  
  |
  
2-2-2
$$

$$
1-1，2-2

  | 
  
 1，2
  
     |
  
2-1，2-1
$$

但就算这样还是不能简单地求出解，那么我们就需要寻找新的思路。这时就想到了可以用逆向思维，把加边改为删边，每次把一个最小的叶链删掉，用队列就可以解决问题。

时间复杂度：$O(n)$

#### code：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,S,s[1000005],h[1000005],w[1000005],ans,f,x,y;
struct P{
	int l,to;
}e[2000005];
queue<int>Q;
bool v[1000005];
int main(){
	scanf("%d %d",&n,&m);
	for(int i=1;i<n;++i){
		scanf("%d %d",&x,&y);s[x]++;s[y]++;
		e[i<<1].to=x;e[i<<1].l=h[y];h[y]=i<<1;
		e[i<<1|1].to=y;e[i<<1|1].l=h[x];h[x]=i<<1|1;
	}
	for(int i=1;i<=n;++i){
		if(s[i]==1){
			Q.push(i);
			w[i]=1;S++;
		}
	}
	S-=m<<1;ans=n;
	while(S>0){
		x=Q.front();Q.pop();
		v[x]=1;
		for(int i=h[x];i;i=e[i].l){
			if(!v[e[i].to]){
				f=e[i].to;
				break;
			}
		}
		s[f]--;
		if(s[f]!=1){
			ans-=w[x];
			S--;
		}
		else {
			w[f]=w[x]+1;
			Q.push(f);
		}
	}
	printf("%d",ans);
}
```

