# [Almost Perfect](https://codeforc.es/contest/1726/problem/E)
### 题面描述
一个长为 $n$的排列$p$是合法的当且仅当 $|p_i-p_i^{-1}| \le 1$(当$p_a=b$时，$p_b^{-1}=a$)。

给定$n$,求长为$n$的合法排列数(Mod 998244353 )
#### 输入
第一行输入一个整数$t$，接下来$t$行，每行一个整数$n$。

$1\leq \sum n \leq 3e5$
#### 输出
共$t$行，每行一个整数，表示的合法排列数(Mod 998244353 )

### 分析
首先建图，假设 $p_i=x$，则连一条$i -> x$的边，最后会得到一堆环的集合，设一个环中的元素按顺序来为$a_0,a_1,a_2···a_{m-1}$，我们需要满足的条件就是 $|a_i-a_{(i+2) Mod \  m}| \leq 1$,那么环的大小就只有可能是 $1,2,4$且当环大小为$4$时,环一定是$x,y,x+1,y+1$的形式。

$1，2$大小的环相对较容易处理，那么我们可以尝试优先处理长为$4$的环，枚举长为$4$的环的个数，第一步先要算出组成长为$4$的环的数的集合有多少种，考虑到每个长为$4$的环都是两对相邻的数，那么设有$k$个长为$4$环，则有2k对相邻的数被选出，考虑将$2k$对数插入剩下$n-4k$个数种，方案数就是$C_{(n-4k)+2k}^{2k}=C_{n-2k}^{2k}$,接下来把$2k$对数组成$4$环，就是把$2k$对数分成$k$组，每组$2$对数，方案数就通过组合数学算出是$\dfrac{2k!}{2^k*k!}$,每个$4$环又有两种构成方式，总方案数乘以$2^k$。

$4$环已经处理好了，接下来处理$1,2$环,设剩下$m$个数组成$1,2$环时方案数为$b_m$,那么我们就可以推推递推公式。设加入一个数 $a_{m+1}$，如果它组成$1$环，方案数就是$b_m$,如果它组成$2$环，就有$m$个数可以和它组成$2$环，剩下的$m-1$数的方案数就是$b_{m-1}$,总方案数就是$m*{b_{m-1}}$,那么我们就有$b_{m+1}=b_m+m*{b_{m-1}}$

那么$k$个$4$环的方案数就是$C_{n-2k}^{2k}*\dfrac{2k!}{2^k*k!}*2^{k}*b_{n-4k}$，枚举$k$，就可以算出结果。
#### 时间复杂度 $O(n)$
#### 空间复杂度 $O(n)$
##### code:
```
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+5,M=998244353;
int n,s[N],f[N],dp[N];
void ck(int &x){x>=M&&(x-=M);}
int pw(int x,int t){
	int rs=1;
	for(;t;t>>=1,x=1ll*x*x%M)if(t&1)rs=1ll*rs*x%M;
	return rs;
}
void so(){
	scanf("%d",&n);
	int rs=0;
	for(int i=0;i<=(n>>2);++i){
		ck(rs+=1ll*s[n-i-i]*f[n-4*i]%M*f[i]%M*dp[n-4*i]%M);
	}
	printf("%d\n",rs);
}
int main(){
	int t;
	n=3e5;
	s[0]=1;
	for(int i=1;i<=n;++i)s[i]=1ll*s[i-1]*i%M;
	f[n]=pw(s[n],M-2);
	for(int i=n;i;i--)f[i-1]=1ll*f[i]*i%M;
	dp[0]=dp[1]=1;
	for(int i=2;i<=n;++i)dp[i]=(1ll*(i-1)*dp[i-2]+dp[i-1])%M;
	scanf("%d",&t);
	while(t--)so();
	return 0;
}
```