# FFT入门

FFT (快速傅里叶变换)，是一个可以在 $O(n \log(n))$时间内完成两个多项式的乘法的算法。

## 前置知识：

#### 多项式的两种表示方法

一般时候多项式都是表达为**系数表示法**,例如：

$$
A(x)=a_0+a_1*x^1+a_2*x^2+a_3*x^3...a_{n-1}*x^{n-1}
$$
最朴素的多项式乘法就是直接枚举系数然后相乘的$O(n^2)$乘法。但是这种算法基本上没有优化的余地。

另一种是**点值表示法**,如果我们带入$n$个不同的$x$,那么我们就可以得到$n$个$y$值，那么这$n$个点就可以**唯一确定**这个多项式。

但直接写两个多项式的相乘（用$n+m$个$x$带入两式，把的到的$y$相乘，再逆解回去）还是一个 $O(n^2)$ 的算法，不过我们FFT优化的就是这个乘法。

#### 复数

我们把形如$z=a+bi$（a,b均为实数）的数称为复数，其中a为实部，b为虚部，i为虚数单位。---百度百科

在复平面中，x代表实部，y轴（除原点外的点）代表虚部，从原点(0,0)到(a,b)的向量表示复数a+bi。

模长：从原点$(0,0)$到点$(a,b)$的距离，即$\sqrt{a^2+b^2} $

幅角：假设以逆时针为正方向，从x轴正半轴到已知向量的转角的有向角叫做幅角

#### 运算法则
加法与向量相同

乘法几何定义：模长相乘，幅角相加

乘法代数定义：$(a+bi)*(c+di)=(ac-bd)+(ad+bc)i$

#### 单位根

在一个复平面上，以原点为原心画一个单位圆，以圆点为起点，圆的$n$等分点为终点，做n个向量。那么我们就把幅角最小的向量对应的复数$\omega ^1_n$成为$n$**次单位根**。

那么通过乘法法则，我们可以把其它的复数表达为$\omega ^k_n,k \in [2,n-1]$

同时，我们也可以发现 $\omega^k_n=\cos \dfrac{2k \pi}{n} + \sin \dfrac{2k \pi}{n} *i$

再通过一些推导和向量尝试，我们就可以得到以下等式：


$$
1.\omega^k_n=\omega^{2k}_{2n}

2.\omega^{k+n/2}_n=-\omega^{k}_{n}
$$

### 进入正题，FFT

设 $n=2^k,k \in N$,因为使用FFT的$n$必须是二的幂次。

对于一个多项式 $A(x)=a_0+a_1*x^1+a_2*x^2+a_3*x^3...a_{n-1}*x^{n-1}$,我们现在要把它化成$(\omega^{0}_{n},y_0),(\omega^{1}_{n},y_1) ...(\omega^{n-1}_{n},y_{n-1}) \}$的点值表达式。

我们分奇偶讨论，把$A(x)$化成

$$
A(x)=(a_0+a_2*x^2...a_{n-2}*x^{n-2})+(a_1*x^1+a_3*x^3...a_{n-1}*x^{n-1})
$$

设$A_1(x)=a_0+a_2*x...a_{n-2}*x^\frac{n-2}{2}$,$A_2(x)=a_1+a_3*x...a_{n-1}*x^\frac{n-2}{2}$,那么：

$$
A(x)= A_1(x^2)+x*A_2(x^2)
$$
也就是说:
$$
A(\omega^k_n)= A_1(\omega^{2k}_n)+x*A_2(\omega^{2k}_n)

=A_1(\omega^{k}_{n/2})+\omega^k_n*A_2(\omega^{k}_{n/2})
$$
<br>

$$
A(\omega^{k+n/2}_n)= A_1(\omega^{2k+n}_n)+\omega^{k+n/2}_n*A_2(\omega^{2k+n}_n)

=A_1(\omega^{k}_{n/2})-\omega^k_n*A_2(\omega^{k}_{n/2})
$$

于是我们可以递归下去求解。

然后我们就可以$O(n)$把两个点值表达式乘起来。

### IFFT
不过我们一般都用系数表达式来表达表达式，接下来我们就要快速的把点值表达式转化为系数表达式。

设$(y_0,y_1...,y_n-1)$为$A(x)$的FFT变换后的值，那么我们设$Y(x)=y_0+y_1*x^1+y_2*x^2+y_3*y^3...y_{n-1}*x^{n-1},b_i=Y(-\omega^i_n)$,那么我们可以得到


$$
b_k= \sum_{i=0}^{n-1} y_i*(\omega^{-k}_n)^i

=\sum_{i=0}^{n-1} (\sum_{j=0}^{n-1} a_j*(\omega^i_n)^j)*(\omega^{-k}_n)^i

=\sum_{j=0}^{n-1} \sum_{i=0}^{n-1} a_j*(\omega^{j-k}_n)^i
$$
当$\omega^{j-k}_n\ !=1$时

$$
\sum_{i=0}^{n-1} a_j*(\omega^{j-k}_n)^i= a_j*\dfrac{(\omega^{j-k}_n)^n-1}{\omega^{j-k}_n-1}

= a_j*\dfrac{\omega^{0}_n-1}{\omega^{j-k}_n-1}=0
$$


对，没了！

当$\omega^{j-k}_n\ =1$时

$$
\sum_{i=0}^{n-1} a_j*(\omega^{j-k}_n)^i= \sum_{i=0}^{n-1} a_j=n*a_j
$$
当$\omega^{j-k}_n\ =1$时，$j=k$。所以我们就有

$$
b_k=n*a_k

a_k=b_k/n
$$

所以我们只要直接再变换一次，把得到的值除n即可得到系数表达式。

##### 伪代码：
```
FFT(len,*a){
    if(len==1)return;
    把a数组按奇偶分配到a1,a2数组；
    FFT(len/2,a1),FFT(len/2,a2);
    Wn={cos(2*pi/len),sin(2*pi/len)};//单位根
    w={cos(0),sin(0)};
    for(i=0;i<len/2;++i){
        a[i]=a1[i]+w*a2[i];
        a[i+len/2]=a[i]-w*a2[i];
        w*=Wn;
    }
    return;
}
```

### 优化：
递归的常数比较大，我们有没有办法可以非递归实现呢？显然是可以的。

一种比较明显的做法就是按自底而上顺序合并的版本，不过需要在两个数组间反复跑动，并不易写。

还有一种就是直接通过反转下标二进制位而得到的，如$n=8$时，我们可以把原序列$\{0,1,2,3,4,5,6,7 \}$转化为$\{0,4,2,6,1,5,3,7 \}$。然后我们再进行合并操作。

可以发现，我们合并时可以直接把得到的两个新数直接放在合并的两个数上。如$n=8$时，我们的序列的变化是

$$
\{0,4,2,6,1,5,3,7 \}

\{0,4,2,6,1,5,3,7 \}

\{0,2,4,6,1,3,5,7 \}

\{0,1,2,3,4,5,6,7 \}
$$
最后就又会变回原序列。

##### code:
```cpp
void FFT(cx *a,int tp){
    for(int i=0;i<up;++i)r[i]=(r[i>>1]| ((i&1)? up:0))>>1;
	for(int i=0;i<up;++i)r[i]=(r[i>>1]>>1)|((i&1)? mid:0);
	for(int i=0;i<up;++i)if(i<r[i])swap(a[i],a[r[i]]);
	for(int i=1;i<up;i<<=1){
		cx Wn=(cx){cos(pi/i),tp*sin(pi/i)};
		for(int o=0,I=i<<1;o<up;o+=I){
			cx w=(cx){1,0};
			for(int u=o,U=i+o;u<U;++u,w=w*Wn){
				cx x=a[u],y=w*a[u+i];
				a[u]=x+y;a[u+i]=x-y;
			}
		}
	}
}

void NTT(int *a,int tp,int up){
	for(int i=1;i<up;++i)if(i<R[i])swap(a[i],a[R[i]]);
	for(int i=1;i<up;i<<=1){
		int Wn=pw(tp? 3:((M+1)/3),(M-1)/i/2);
		for(int o=0;o<up;o+=i){
			for(int w=1,U=o+i;o<U;++o,w=1ll*w*Wn%M){
				int x=a[o],y=1ll*w*a[o+i]%M;
				ck(a[o]=x+y);kc(a[o+i]=x-y);
			}
		}
	}
	if(!tp){
		int k=pw(up,M-2);
		for(int i=0;i<up;++i)a[i]=1ll*a[i]*k%M;
	}
}
```
