# 二分图匹配

#### 原理：
当一个图可以被分为两半，每一半中的点与点间都没有连边。那么这个图就是二分图。而二分图的最大匹配可以有匈牙利算法完成。
#### 匈牙利算法：
匈牙利算法基于贪心，原理就是每一次都尝试去加一个点，如果找到了就插进去，没找到就不变。因为每个点最多只有一条边连起来，所以不存在把一对点连起来而导致原本可以连起来的两对点（这四点不包括那已连的两个点）连不起来。由于每一次尝试加点最多遍历整个图一次，所以时间复杂度是 $O(nm)$
#### 解决问题：
最小路径覆盖，最大独立子集，最大匹配，最小顶点覆盖。

题目中有二维直角坐标系的题可能会运用到二分图。

#### 板子：

```
struct eft{//N_node --> M_node，左找右
	struct E{
		int to,l;
	}e[cnt_e];
	int n,m,k,ma[M],ans,h[N],a,b;//ma是右边第i个在左边匹配的点
	bool v[M];
	bool so(int x){
		for(int i=h[x];i;i=e[i].l){
			if(!v[e[i].to]){
				v[e[i].to]=1;
				if(!ma[e[i].to]||so(ma[e[i].to])){
					ma[e[i].to]=x;
					return 1;
				}
			}
		}
		return 0;
	}
	void slv(){
		for(int i=1;i<=n;++i){
			for(int i=1;i<=m;++i)v[i]=0;
			if(so(i))su++;
		}
	}
}
```