# 聚变反应炉
[SHOI2015](http://10.220.121.203/judge/problem.php?id=3719)
### 题目描述
曾经发明了零件组装机的发明家 SHTSC 又公开了他的新发明：聚变反应炉

——一种可以产生大量清洁能量的神秘装置。

众所周知，利用核聚变产生的能量有两个难点：一是控制核聚变反应的反应强度，二是使用较少的能量激发聚变反应。而 SHTSC 已经完美解决了第一个问题。

一个聚变反应炉由若干个相连的聚变块组成，为了能够使得聚变反应可控， SHTSC 保证任意两个聚能块都可以通过相互之间的链接到达，并且没有一个聚能块可以不重复经过一个链接回到它自己。

但是第二个问题 SHTSC 还没有完全解决。在他设计的聚变反应炉当中，每个聚变块都需要一定的初始能量 di 来进行激发，不过 SHTSC 不需要手动激发所有聚变块，这是因为一旦一个聚变块被激发，则会向与其直接相连的所有还未被激发的聚变块传送 ci 个单位的能量。这样后被触发的聚变块可以以更低的初始能量来激发，甚至可能不需要额外的外界能量就可自行激发，从而降低了总激发能量的消耗。现在给出了一个聚变反应炉，求至少要多少能量才能激发所有聚变块。

#### 输入
第一行一个整数 n，表示共有 n个聚能块，由1至 n 编号。 第二行 n个整数，依次表示 di。 第三行 n个整数，依次表示 ci。 以下 n−1行每行两个整数 u,v，表示编号为 u 和 v 的聚能块是相连的。

#### 输出
一行一个整数，表示至少需要多少个单位的能量才能激发所有聚变块。

## 分析：
### 状态定义
这个树形DP的状态定义不好想，如果要将该点有没有被激发作为状态进行转移，那么由于有连续触发的连锁效应从而导致状态数不能DP。那么我们就得根据题目中的特性来定义一个可行的状态。

考虑题目中是一颗树，每一条边一定连着一对父子。而这条边造成的影响就是这对父子中谁先被激发给另一边传能量。想到这我们就可以定义状态了。一个点的状态有两个，分别表示**比父亲【先/后】激发**。这样DP的转移就被定在一对父子间,剩下的转移方程也就很好想了。
### 状态转移
这里就需要针对两种不同数据的特性使用不一样的方法来解决。
#### 1.$n\leq100000,c\leq1$
关于这种状态虽然n比较大，但是c却只有1，所以每一条边最多产生的贡献就是1。那么我们就要尽量让最多的边可以有贡献。

首先给出 $dp[后][x]-dp[前][x]\leq1$，因为父亲的影响最多只是一点的贡献。

DP到x时，考虑x的儿子们，如果它的儿子比它先激发时的花费等于比它后激发时的花费，这时还让父亲给它能量，边的贡献就是0，所以我们就让儿子给它父亲能量，这一定更优。而它的儿子比它先激发时的花费大于比它后激发时的花费，那么我们就让父亲给它能量，边的贡献就是1，这也一定更优。
##### 时间复杂度：$O(n)$
#### 2.$n\leq2000,c\leq5$
这里就跟n比较小有关了，我们可以DP套DP。

首先在x的时候，$td[i]$表示儿子们传上来i点能量时的最小花费，在传上来的能量大于d[x]时就降为d[x]，那么对于每一个儿子，我们一定要**在【先\后】激活中选一个**。当我们选后激活时，DP的转移就是:(以默认加了滚动数组)
$$
td[i]=td[i]+dp[1][son];
$$
而另一种情况就是:
$$
td[\min(d[x],i+c[son])]=td[i]+dp[0][son];
$$
` $dp[0/1][x] $的定义为先/后于父亲激发。

而最后一步就是将$td$数组给转移到$dp$数组中，也就是

$$
dp[0][x]=\min_{i=1}^{d[x]}({td[i]+\max(d[x]-i,0))}
$$
$$
dp[1][x]=\min_{i=1}^{d[x]}({td[i]+\max(d[x]-i-c[fa],0))}
$$
##### 时间复杂度 $O(n^2*c)$

问题解决！
##### code：

```
#include<bits/stdc++.h>
using namespace std;
const int N=100005;
int n,d[N],c[N],h[N],ma;
struct E{
	int l,to;
}e[N<<1];
void Min(int &x,int y){if(x>y)x=y;}
struct so1{
	int dp[2][100005];
	void se(int x,int f){
		for(int i=h[x];i;i=e[i].l){
			int to=e[i].to;
			if(f==to)continue;
			se(to,x);
			dp[0][x]+=min(dp[0][to],dp[1][to]);
			if(dp[0][to]==dp[1][to]&&c[to])d[x]--;
		}
		dp[1][x]=dp[0][x]+max(d[x]-c[f],0);
		dp[0][x]+=max(d[x],0);
	}
	so1(){
		memset(dp,0,sizeof(dp));
		se(1,0);
		printf("%d\n",dp[0][1]);
	} 
};
struct so2{
	int dp[2][2005],td[10005];
	void se(int x,int f){
		int sc=0;
		for(int i=h[x];i;i=e[i].l){
			int to=e[i].to;
			if(to==f)continue;
			se(to,x);
			sc+=c[to];
		}
		sc=min(sc,d[x]);
		for(int i=1;i<=sc;++i)td[i]=1e9;
		td[0]=0;
		for(int i=h[x];i;i=e[i].l){
			int to=e[i].to;
			if(to==f)continue;
			for(int o=sc;o>=0;o--){
				Min(td[min(o+c[to],sc)],td[o]+dp[0][to]);
				td[o]+=dp[1][to];
			}
		}
		for(int i=sc;i>=0;i--){
			Min(dp[0][x],td[i]+max(d[x]-i,0));
			Min(dp[1][x],td[i]+max(d[x]-i-c[f],0));
		}
	}
	so2(){
		memset(dp,127,sizeof(dp));
		se(1,0);
		printf("%d\n",dp[0][1]);
	}
};
int main(){
	int x,y;
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		scanf("%d",&d[i]);
	}
	for(int i=1;i<=n;++i){
		scanf("%d",&c[i]);
		ma=max(ma,c[i]);
	}
	for(int i=1;i<n;++i){
		scanf("%d %d",&x,&y);
		e[i<<1].to=x;e[i<<1].l=h[y];h[y]=i<<1;
		e[i<<1|1].to=y;e[i<<1|1].l=h[x];h[x]=i<<1|1;
	}
	if(ma<=1)so1 A;
	else so2 A;
}
```
