# 数位DP
数位DP就是对该位置选了什么数进行DP。一般来说是求出某一个区间中符合要求的数的个数。有时要考虑前导零造成的影响。

实际上，数位DP是一种暴力模拟的算法，只不过使用了记忆化搜索，使时间花费减小。

每一次dfs时，bool li表示数否有限制，int nl 表示这枚举到了第几位，剩下的看题目要求来自由发挥。

### 入门例题：不要62 
[链接](https://cn.vjudge.net/contest/294388#problem/A)

关于这题，在时枚举时碰到4就continue掉，记录下上一次选择的数是什么，如果与这次选择的数组合成62,也continue掉就可以了。

### 进阶：恨7不成妻 
[题目](https://cn.vjudge.net/contest/294388#problem/J)

对于数的要求，只要在枚举时碰到7就跳过，记录下之前所有数位的和与值模7的余数就可以解决。但是对于求符合的数的平方和，这就需要YY了。

设S为 $ a1^2+a2^2+..ax^2 $,a数组为当前数位及以后的所有符合的数。那么在返回合并的过程中，就是把a数组中每一位数的前面都加上一个数。那么新的答案就是$ (b+a1)^2+(b+a2)^2+..(b+ax)^2 $,把括号拆开之后就得到

$ a1^2+a2^2+..ax^2+2*b*\sum a+x*b^2$

所有我们记录下3个信息，一个平方和，一个和，一个当前a的个数就可以进行转移了。
### 变种：k倍数字（反序）
[题目链接](http://10.220.121.203/judge/problem.php?id=3703)

#### 题目描述
给定两个数字R和k，求满足下列条件的x个数。

（1）满足1≤x≤R

（2）定义函数f(x) 为 x 的各位数字之和，例如f(13)=4,f(233)=8。满足 f(x)=f(k·x)

##### 输入
输入的第一行有两个正整数R，k。

##### 输出
仅一个整数，表示可能的整数 x 有多少个。

#### 分析：
如果这仍从高到低来做，那么进位而产生的影响就很难得到解决，因为可能会影响到几乎所有已选的数字，状态也难以定义。由于问题是进位导致的，所以我们就要从进位的方向思考。这时如果我们先选低位，再选高位，那么进位的问题就十分简单了。
##### code:
```
#include<bits/stdc++.h>
using namespace std;
long long n,dp[1005][405][22][2];
int k,l,d[55],s[1005];
long long dfs(int nl,int w,int j,bool up){
    if(nl>l)return up&&s[j]==w-200;
    if(~dp[j][w][nl][up])return dp[j][w][nl][up];
    long long rs=0;
    for(int i=0;i<10;++i){
        int a=j+i*k,g=a/10;
        rs+=dfs(nl+1,w+i-a+g*10,g,(i<d[nl])||(up&&i==d[nl]));
    }
    return dp[j][w][nl][up]=rs;
}
int main(){
    memset(dp,-1,sizeof(dp));
    scanf("%lld %d",&n,&k);
    while(n){d[++l]=n%10;n/=10;}
    for(int i=1;i<=k;++i)s[i]=s[i/10]+i%10;
    printf("%lld\n",dfs(1,200,0,1)-1);
}
```