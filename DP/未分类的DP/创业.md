# [创业](https://www.cometoj.com/problem/1796)
### 题面
小 X 最近想要创业。

他有一个 n 个人的团队，为了能够创业成功，小 X 决定将这 
n 个人分成若干组，分工合作。

但是，每个人都不希望自己所在的分组中人数过多，因此每个人都有一个所在小组人数的上限。

请你求出不同的分组方案的个数，答案对 P 取模。

两种分组方案不同，当且仅当存在两个人，他们在第一种方案中处于同一组，在第二种方案中处于不同组。

$n \le 2000$
### 分析：
这道题中，有关的量有人数，组数，人的上限和组的人数。
我们要通过一些手段，合理分配这些量，使我们可以DP起来。

首先，我们可以发现，一个组的人数上限是由组中上限最小的人决定的，那么当我们确定组的大小时，我们就可以把可以加入这个组的人给定下来。所以我们就可以通过枚举组的大小，顺便通过这个性质消掉人的上限的影响。那么剩下的组数和人数我们也可以直接进行枚举。由于组的人数*组的大小最多是n,所以在这累的复杂度就是$O(n \ln n)$,再加上枚举人数的复杂度，就是$O(n^2 \ln n)$。

接下来，就是列状态转移方程的时间。设dp[i][j]为当前选用的组的大小为i,剩下有j人的方案数，那么我们就要从大到小枚举i（因为上限大的人可以加入人数小的组，但是上限小的人不能加入人数大的组），接着我们要加入a[i]个人，即右移a[i]距离dp[i+1]数组，接着复制dp[i+1]数组到dp[i],当作选0组的情况。接着考虑选了k组时的转移，就是：

$$
dp[i][j-k*i]+=dp[i+1][j]*solve(j,i,k)
$$

其中solve(j,i,k)就是剩下j人，i人一组，选k组的方案数。
那么就是选j个人的方案数除以组中人的排列数再除以组的排列数，通过这些，我们就可以发现

$$
solve(j,i,k)=\dfrac{j!}{(i!)^k*(j-i*k)!*k!}
$$

再加上我们的模数是质数，所以扩欧或费小就可以处理逆元，$O(n)$预处理阶乘即可。

遇到难题不要慌，慢慢剖析其实也不难。

##### code：
```#include<bits/stdc++.h>
using namespace std;
const int N=2005;
int n,m,dp[N][N],a[N],f[N],s[N],fs[N];
int main(){
    scanf("%d %d",&n,&m);
    const int M=m;
    for(int i=1;i<=n;++i){
        scanf("%d",&a[i]);
    }
    s[0]=fs[0]=1;
    for(int i=1;i<=n;++i){
        s[i]=1ll*s[i-1]*i%M;
        f[i]=1;
        int t=M-2,w=i;
        for(int o=1;o<=m;o<<=1){
            if(t&o)f[i]=1ll*f[i]*w%M;
            w=1ll*w*w%M;
        }
        fs[i]=1ll*fs[i-1]*f[i]%M;
    }
    dp[n+1][0]=1;
    int S=0;
    for(int i=n;i;i--){
        S+=a[i];
        for(int o=S;o>=a[i];--o)dp[i][o]=dp[i+1][o]=dp[i+1][o-a[i]];
        for(int o=a[i]-1;o>=0;o--)dp[i+1][o]=0;
        register int G=1;
        for(int o=1;o*i<=S;++o){
            G=1ll*G*fs[i]%M*f[o]%M;
            const int d=o*i;
             for(int u=S;u>=d;--u){
                dp[i][u-d]+=1ll*dp[i+1][u]*s[u]%M*G%M*fs[u-d]%M;
                if(dp[i][u-d]>=M)dp[i][u-d]-=M;
            }
        }
    }
    printf("%d\n",dp[1][0]);
}
```