# [日历](http://uoj.ac/problem/137)
### 问题简介
一个$n\times m$的网格图，每个格子里面的数开始时都是 $0$，有 $q$ 次操作，每一次操作输入$v,u,k$，对于所有满足$0\le i \le j$且$k \le j$的 $(i,j)$ ，把网格 $(v+i,u-i+j)$中的数增加 $C_j^i$。问所有操作后每个网格的数分别是多少

$n,m\le 300, q \le 5·10^6$
### 分析：
通过模拟和数学分析，我们可以发现，每一次在(u,v)点来一次k的操作，就是以(u,v)作为一个矩形的左上角，加上一个偏转了45°的杨辉三角。并削掉左上角边长为k的等腰三角形。那么问题就在如何快速地将贡献算出来。

首先是暴力的O($qn^2$)做法。就按题目里描述的做法枚举加上贡献，预处理组合数。

接着，就是优化。因为这是倒了45°的杨辉三角，那么杨辉三角的递推式一定也适用于此。那么每一次我们都只加上距离为k的点的贡献，最后我们再

然而q的极大范围让O($qn$)的做法都行不通，那么我们就只能退而求其次，想一个复杂度更小的处理方法(~~比如O(log(n)))。考虑到距离的问题，我们需要一个办法快速求出。那么我们可以通过多维降解来解决这个问题。

每一次q，把$dp[u][v][k]$++。当所有的操作都结束之后，再从大到小一维一维降下来。这样子，就可以把三角形削掉。

##### 时间复杂度 $O(n^3 + q)$
##### code :
```
#include<bits/stdc++.h>
#define rg register
using namespace std;
const int M=998244353;
int n,m,q,t,v,u,k,dp[605][305][305],D;
int main(){
    scanf("%d %d %d %d",&n,&m,&q,&t);
    rg int x=t;
    while(q--){
        x=(1ll*100000005*x+20150823)%M;
        v=(x/100)%n+1;
        x=(1ll*100000005*x+20150823)%M;
        u=(x/100)%m+1;
        x=(1ll*100000005*x+20150823)%M;
        k=(x/100)%(n+m-u-v+1);
        dp[k][v][u]++;
        D=max(D,k);
    }
    for(rg int i=D-1;i>=0;i--){
        for(rg int o=1;o<=n;++o){
            for(rg int u=1;u<=m;++u){
                dp[i][o][u]+=dp[i+1][o-1][u];
                if(dp[i][o][u]>=M)dp[i][o][u]-=M;
                dp[i][o][u]+=dp[i+1][o][u-1];
                if(dp[i][o][u]>=M)dp[i][o][u]-=M;
            }
        }
    }
    for(int o=1;o<=n;++o){
        for(int u=1;u<=m;++u){
            dp[0][o][u]+=dp[0][o-1][u];
            if(dp[0][o][u]>=M)dp[0][o][u]-=M;
            dp[0][o][u]+=dp[0][o][u-1];
            if(dp[0][o][u]>=M)dp[0][o][u]-=M;
            printf("%d ",dp[0][o][u]);
        }printf("\n");
    }
    return 0;
}
```